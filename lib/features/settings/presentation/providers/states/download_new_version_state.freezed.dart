// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'download_new_version_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;


final _privateConstructorUsedError = UnsupportedError('It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$DownloadNewVersionState {


@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  preparing,required TResult Function( String progress)  downloading,required TResult Function( File file)  success,required TResult Function( AppFailure failure)  failure,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  preparing,TResult? Function( String progress)?  downloading,TResult? Function( File file)?  success,TResult? Function( AppFailure failure)?  failure,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  preparing,TResult Function( String progress)?  downloading,TResult Function( File file)?  success,TResult Function( AppFailure failure)?  failure,required TResult orElse(),}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _Init value)  init,required TResult Function( _Preparing value)  preparing,required TResult Function( _Downloading value)  downloading,required TResult Function( _DownloadSuccess value)  success,required TResult Function( _DownloadFailure value)  failure,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _Init value)?  init,TResult? Function( _Preparing value)?  preparing,TResult? Function( _Downloading value)?  downloading,TResult? Function( _DownloadSuccess value)?  success,TResult? Function( _DownloadFailure value)?  failure,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _Init value)?  init,TResult Function( _Preparing value)?  preparing,TResult Function( _Downloading value)?  downloading,TResult Function( _DownloadSuccess value)?  success,TResult Function( _DownloadFailure value)?  failure,required TResult orElse(),}) => throw _privateConstructorUsedError;


}

/// @nodoc
abstract class $DownloadNewVersionStateCopyWith<$Res>  {
  factory $DownloadNewVersionStateCopyWith(DownloadNewVersionState value, $Res Function(DownloadNewVersionState) then) = _$DownloadNewVersionStateCopyWithImpl<$Res, DownloadNewVersionState>;



}

/// @nodoc
class _$DownloadNewVersionStateCopyWithImpl<$Res,$Val extends DownloadNewVersionState> implements $DownloadNewVersionStateCopyWith<$Res> {
  _$DownloadNewVersionStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;



}


/// @nodoc
abstract class _$$InitImplCopyWith<$Res>  {
  factory _$$InitImplCopyWith(_$InitImpl value, $Res Function(_$InitImpl) then) = __$$InitImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res> extends _$DownloadNewVersionStateCopyWithImpl<$Res, _$InitImpl> implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);





}

/// @nodoc


class _$InitImpl extends _Init  {
  const _$InitImpl(): super._();

  



@override
String toString() {
  return 'DownloadNewVersionState.init()';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$InitImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  preparing,required TResult Function( String progress)  downloading,required TResult Function( File file)  success,required TResult Function( AppFailure failure)  failure,}) {
  return init();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  preparing,TResult? Function( String progress)?  downloading,TResult? Function( File file)?  success,TResult? Function( AppFailure failure)?  failure,}) {
  return init?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  preparing,TResult Function( String progress)?  downloading,TResult Function( File file)?  success,TResult Function( AppFailure failure)?  failure,required TResult orElse(),}) {
  if (init != null) {
    return init();
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _Init value)  init,required TResult Function( _Preparing value)  preparing,required TResult Function( _Downloading value)  downloading,required TResult Function( _DownloadSuccess value)  success,required TResult Function( _DownloadFailure value)  failure,}) {
  return init(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _Init value)?  init,TResult? Function( _Preparing value)?  preparing,TResult? Function( _Downloading value)?  downloading,TResult? Function( _DownloadSuccess value)?  success,TResult? Function( _DownloadFailure value)?  failure,}) {
  return init?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _Init value)?  init,TResult Function( _Preparing value)?  preparing,TResult Function( _Downloading value)?  downloading,TResult Function( _DownloadSuccess value)?  success,TResult Function( _DownloadFailure value)?  failure,required TResult orElse(),}) {
  if (init != null) {
    return init(this);
  }
  return orElse();
}

}


abstract class _Init extends DownloadNewVersionState {
  const factory _Init() = _$InitImpl;
  const _Init._(): super._();

  



}

/// @nodoc
abstract class _$$PreparingImplCopyWith<$Res>  {
  factory _$$PreparingImplCopyWith(_$PreparingImpl value, $Res Function(_$PreparingImpl) then) = __$$PreparingImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$PreparingImplCopyWithImpl<$Res> extends _$DownloadNewVersionStateCopyWithImpl<$Res, _$PreparingImpl> implements _$$PreparingImplCopyWith<$Res> {
  __$$PreparingImplCopyWithImpl(_$PreparingImpl _value, $Res Function(_$PreparingImpl) _then)
      : super(_value, _then);





}

/// @nodoc


class _$PreparingImpl extends _Preparing  {
  const _$PreparingImpl(): super._();

  



@override
String toString() {
  return 'DownloadNewVersionState.preparing()';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$PreparingImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  preparing,required TResult Function( String progress)  downloading,required TResult Function( File file)  success,required TResult Function( AppFailure failure)  failure,}) {
  return preparing();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  preparing,TResult? Function( String progress)?  downloading,TResult? Function( File file)?  success,TResult? Function( AppFailure failure)?  failure,}) {
  return preparing?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  preparing,TResult Function( String progress)?  downloading,TResult Function( File file)?  success,TResult Function( AppFailure failure)?  failure,required TResult orElse(),}) {
  if (preparing != null) {
    return preparing();
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _Init value)  init,required TResult Function( _Preparing value)  preparing,required TResult Function( _Downloading value)  downloading,required TResult Function( _DownloadSuccess value)  success,required TResult Function( _DownloadFailure value)  failure,}) {
  return preparing(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _Init value)?  init,TResult? Function( _Preparing value)?  preparing,TResult? Function( _Downloading value)?  downloading,TResult? Function( _DownloadSuccess value)?  success,TResult? Function( _DownloadFailure value)?  failure,}) {
  return preparing?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _Init value)?  init,TResult Function( _Preparing value)?  preparing,TResult Function( _Downloading value)?  downloading,TResult Function( _DownloadSuccess value)?  success,TResult Function( _DownloadFailure value)?  failure,required TResult orElse(),}) {
  if (preparing != null) {
    return preparing(this);
  }
  return orElse();
}

}


abstract class _Preparing extends DownloadNewVersionState {
  const factory _Preparing() = _$PreparingImpl;
  const _Preparing._(): super._();

  



}

/// @nodoc
abstract class _$$DownloadingImplCopyWith<$Res>  {
  factory _$$DownloadingImplCopyWith(_$DownloadingImpl value, $Res Function(_$DownloadingImpl) then) = __$$DownloadingImplCopyWithImpl<$Res>;
@useResult
$Res call({
 String progress
});



}

/// @nodoc
class __$$DownloadingImplCopyWithImpl<$Res> extends _$DownloadNewVersionStateCopyWithImpl<$Res, _$DownloadingImpl> implements _$$DownloadingImplCopyWith<$Res> {
  __$$DownloadingImplCopyWithImpl(_$DownloadingImpl _value, $Res Function(_$DownloadingImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? progress = null,}) {
  return _then(_$DownloadingImpl(
null == progress ? _value.progress : progress // ignore: cast_nullable_to_non_nullable
as String,
  ));
}


}

/// @nodoc


class _$DownloadingImpl extends _Downloading  {
  const _$DownloadingImpl(this.progress): super._();

  

@override final  String progress;

@override
String toString() {
  return 'DownloadNewVersionState.downloading(progress: $progress)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$DownloadingImpl&&(identical(other.progress, progress) || other.progress == progress));
}


@override
int get hashCode => Object.hash(runtimeType,progress);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$DownloadingImplCopyWith<_$DownloadingImpl> get copyWith => __$$DownloadingImplCopyWithImpl<_$DownloadingImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  preparing,required TResult Function( String progress)  downloading,required TResult Function( File file)  success,required TResult Function( AppFailure failure)  failure,}) {
  return downloading(progress);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  preparing,TResult? Function( String progress)?  downloading,TResult? Function( File file)?  success,TResult? Function( AppFailure failure)?  failure,}) {
  return downloading?.call(progress);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  preparing,TResult Function( String progress)?  downloading,TResult Function( File file)?  success,TResult Function( AppFailure failure)?  failure,required TResult orElse(),}) {
  if (downloading != null) {
    return downloading(progress);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _Init value)  init,required TResult Function( _Preparing value)  preparing,required TResult Function( _Downloading value)  downloading,required TResult Function( _DownloadSuccess value)  success,required TResult Function( _DownloadFailure value)  failure,}) {
  return downloading(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _Init value)?  init,TResult? Function( _Preparing value)?  preparing,TResult? Function( _Downloading value)?  downloading,TResult? Function( _DownloadSuccess value)?  success,TResult? Function( _DownloadFailure value)?  failure,}) {
  return downloading?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _Init value)?  init,TResult Function( _Preparing value)?  preparing,TResult Function( _Downloading value)?  downloading,TResult Function( _DownloadSuccess value)?  success,TResult Function( _DownloadFailure value)?  failure,required TResult orElse(),}) {
  if (downloading != null) {
    return downloading(this);
  }
  return orElse();
}

}


abstract class _Downloading extends DownloadNewVersionState {
  const factory _Downloading(final  String progress) = _$DownloadingImpl;
  const _Downloading._(): super._();

  

 String get progress;
@JsonKey(ignore: true)
_$$DownloadingImplCopyWith<_$DownloadingImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$DownloadSuccessImplCopyWith<$Res>  {
  factory _$$DownloadSuccessImplCopyWith(_$DownloadSuccessImpl value, $Res Function(_$DownloadSuccessImpl) then) = __$$DownloadSuccessImplCopyWithImpl<$Res>;
@useResult
$Res call({
 File file
});



}

/// @nodoc
class __$$DownloadSuccessImplCopyWithImpl<$Res> extends _$DownloadNewVersionStateCopyWithImpl<$Res, _$DownloadSuccessImpl> implements _$$DownloadSuccessImplCopyWith<$Res> {
  __$$DownloadSuccessImplCopyWithImpl(_$DownloadSuccessImpl _value, $Res Function(_$DownloadSuccessImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? file = null,}) {
  return _then(_$DownloadSuccessImpl(
null == file ? _value.file : file // ignore: cast_nullable_to_non_nullable
as File,
  ));
}


}

/// @nodoc


class _$DownloadSuccessImpl extends _DownloadSuccess  {
  const _$DownloadSuccessImpl(this.file): super._();

  

@override final  File file;

@override
String toString() {
  return 'DownloadNewVersionState.success(file: $file)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$DownloadSuccessImpl&&(identical(other.file, file) || other.file == file));
}


@override
int get hashCode => Object.hash(runtimeType,file);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$DownloadSuccessImplCopyWith<_$DownloadSuccessImpl> get copyWith => __$$DownloadSuccessImplCopyWithImpl<_$DownloadSuccessImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  preparing,required TResult Function( String progress)  downloading,required TResult Function( File file)  success,required TResult Function( AppFailure failure)  failure,}) {
  return success(file);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  preparing,TResult? Function( String progress)?  downloading,TResult? Function( File file)?  success,TResult? Function( AppFailure failure)?  failure,}) {
  return success?.call(file);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  preparing,TResult Function( String progress)?  downloading,TResult Function( File file)?  success,TResult Function( AppFailure failure)?  failure,required TResult orElse(),}) {
  if (success != null) {
    return success(file);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _Init value)  init,required TResult Function( _Preparing value)  preparing,required TResult Function( _Downloading value)  downloading,required TResult Function( _DownloadSuccess value)  success,required TResult Function( _DownloadFailure value)  failure,}) {
  return success(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _Init value)?  init,TResult? Function( _Preparing value)?  preparing,TResult? Function( _Downloading value)?  downloading,TResult? Function( _DownloadSuccess value)?  success,TResult? Function( _DownloadFailure value)?  failure,}) {
  return success?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _Init value)?  init,TResult Function( _Preparing value)?  preparing,TResult Function( _Downloading value)?  downloading,TResult Function( _DownloadSuccess value)?  success,TResult Function( _DownloadFailure value)?  failure,required TResult orElse(),}) {
  if (success != null) {
    return success(this);
  }
  return orElse();
}

}


abstract class _DownloadSuccess extends DownloadNewVersionState {
  const factory _DownloadSuccess(final  File file) = _$DownloadSuccessImpl;
  const _DownloadSuccess._(): super._();

  

 File get file;
@JsonKey(ignore: true)
_$$DownloadSuccessImplCopyWith<_$DownloadSuccessImpl> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class _$$DownloadFailureImplCopyWith<$Res>  {
  factory _$$DownloadFailureImplCopyWith(_$DownloadFailureImpl value, $Res Function(_$DownloadFailureImpl) then) = __$$DownloadFailureImplCopyWithImpl<$Res>;
@useResult
$Res call({
 AppFailure failure
});


$AppFailureCopyWith<$Res> get failure;
}

/// @nodoc
class __$$DownloadFailureImplCopyWithImpl<$Res> extends _$DownloadNewVersionStateCopyWithImpl<$Res, _$DownloadFailureImpl> implements _$$DownloadFailureImplCopyWith<$Res> {
  __$$DownloadFailureImplCopyWithImpl(_$DownloadFailureImpl _value, $Res Function(_$DownloadFailureImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? failure = null,}) {
  return _then(_$DownloadFailureImpl(
null == failure ? _value.failure : failure // ignore: cast_nullable_to_non_nullable
as AppFailure,
  ));
}

@override
@pragma('vm:prefer-inline')
$AppFailureCopyWith<$Res> get failure {
  
  return $AppFailureCopyWith<$Res>(_value.failure, (value) {
    return _then(_value.copyWith(failure: value) );
  });
}
}

/// @nodoc


class _$DownloadFailureImpl extends _DownloadFailure  {
  const _$DownloadFailureImpl(this.failure): super._();

  

@override final  AppFailure failure;

@override
String toString() {
  return 'DownloadNewVersionState.failure(failure: $failure)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$DownloadFailureImpl&&(identical(other.failure, failure) || other.failure == failure));
}


@override
int get hashCode => Object.hash(runtimeType,failure);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$DownloadFailureImplCopyWith<_$DownloadFailureImpl> get copyWith => __$$DownloadFailureImplCopyWithImpl<_$DownloadFailureImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  preparing,required TResult Function( String progress)  downloading,required TResult Function( File file)  success,required TResult Function( AppFailure failure)  failure,}) {
  return failure(this.failure);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  preparing,TResult? Function( String progress)?  downloading,TResult? Function( File file)?  success,TResult? Function( AppFailure failure)?  failure,}) {
  return failure?.call(this.failure);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  preparing,TResult Function( String progress)?  downloading,TResult Function( File file)?  success,TResult Function( AppFailure failure)?  failure,required TResult orElse(),}) {
  if (failure != null) {
    return failure(this.failure);
  }
  return orElse();
}
@override
@optionalTypeArgs TResult map<TResult extends Object?>({required TResult Function( _Init value)  init,required TResult Function( _Preparing value)  preparing,required TResult Function( _Downloading value)  downloading,required TResult Function( _DownloadSuccess value)  success,required TResult Function( _DownloadFailure value)  failure,}) {
  return failure(this);
}
@override
@optionalTypeArgs TResult? mapOrNull<TResult extends Object?>({TResult? Function( _Init value)?  init,TResult? Function( _Preparing value)?  preparing,TResult? Function( _Downloading value)?  downloading,TResult? Function( _DownloadSuccess value)?  success,TResult? Function( _DownloadFailure value)?  failure,}) {
  return failure?.call(this);
}
@override
@optionalTypeArgs TResult maybeMap<TResult extends Object?>({TResult Function( _Init value)?  init,TResult Function( _Preparing value)?  preparing,TResult Function( _Downloading value)?  downloading,TResult Function( _DownloadSuccess value)?  success,TResult Function( _DownloadFailure value)?  failure,required TResult orElse(),}) {
  if (failure != null) {
    return failure(this);
  }
  return orElse();
}

}


abstract class _DownloadFailure extends DownloadNewVersionState {
  const factory _DownloadFailure(final  AppFailure failure) = _$DownloadFailureImpl;
  const _DownloadFailure._(): super._();

  

 AppFailure get failure;
@JsonKey(ignore: true)
_$$DownloadFailureImplCopyWith<_$DownloadFailureImpl> get copyWith => throw _privateConstructorUsedError;

}
