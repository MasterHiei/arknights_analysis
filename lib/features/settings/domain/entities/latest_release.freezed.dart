// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'latest_release.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;


final _privateConstructorUsedError = UnsupportedError('It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$LatestRelease {

 int get id => throw _privateConstructorUsedError; String get nodeId => throw _privateConstructorUsedError; String get name => throw _privateConstructorUsedError; String get tagName => throw _privateConstructorUsedError; bool get draft => throw _privateConstructorUsedError; bool get prerelease => throw _privateConstructorUsedError; DateTime get createdAt => throw _privateConstructorUsedError; DateTime get publishedAt => throw _privateConstructorUsedError; List<LatestReleaseAsset> get assets => throw _privateConstructorUsedError;







/// Create a copy of LatestRelease
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
$LatestReleaseCopyWith<LatestRelease> get copyWith => throw _privateConstructorUsedError;

}

/// @nodoc
abstract class $LatestReleaseCopyWith<$Res>  {
  factory $LatestReleaseCopyWith(LatestRelease value, $Res Function(LatestRelease) then) = _$LatestReleaseCopyWithImpl<$Res, LatestRelease>;
@useResult
$Res call({
 int id, String nodeId, String name, String tagName, bool draft, bool prerelease, DateTime createdAt, DateTime publishedAt, List<LatestReleaseAsset> assets
});



}

/// @nodoc
class _$LatestReleaseCopyWithImpl<$Res,$Val extends LatestRelease> implements $LatestReleaseCopyWith<$Res> {
  _$LatestReleaseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

/// Create a copy of LatestRelease
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? nodeId = null,Object? name = null,Object? tagName = null,Object? draft = null,Object? prerelease = null,Object? createdAt = null,Object? publishedAt = null,Object? assets = null,}) {
  return _then(_value.copyWith(
id: null == id ? _value.id : id // ignore: cast_nullable_to_non_nullable
as int,nodeId: null == nodeId ? _value.nodeId : nodeId // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _value.name : name // ignore: cast_nullable_to_non_nullable
as String,tagName: null == tagName ? _value.tagName : tagName // ignore: cast_nullable_to_non_nullable
as String,draft: null == draft ? _value.draft : draft // ignore: cast_nullable_to_non_nullable
as bool,prerelease: null == prerelease ? _value.prerelease : prerelease // ignore: cast_nullable_to_non_nullable
as bool,createdAt: null == createdAt ? _value.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime,publishedAt: null == publishedAt ? _value.publishedAt : publishedAt // ignore: cast_nullable_to_non_nullable
as DateTime,assets: null == assets ? _value.assets : assets // ignore: cast_nullable_to_non_nullable
as List<LatestReleaseAsset>,
  )as $Val);
}

}


/// @nodoc
abstract class _$$LatestReleaseImplCopyWith<$Res> implements $LatestReleaseCopyWith<$Res> {
  factory _$$LatestReleaseImplCopyWith(_$LatestReleaseImpl value, $Res Function(_$LatestReleaseImpl) then) = __$$LatestReleaseImplCopyWithImpl<$Res>;
@override @useResult
$Res call({
 int id, String nodeId, String name, String tagName, bool draft, bool prerelease, DateTime createdAt, DateTime publishedAt, List<LatestReleaseAsset> assets
});



}

/// @nodoc
class __$$LatestReleaseImplCopyWithImpl<$Res> extends _$LatestReleaseCopyWithImpl<$Res, _$LatestReleaseImpl> implements _$$LatestReleaseImplCopyWith<$Res> {
  __$$LatestReleaseImplCopyWithImpl(_$LatestReleaseImpl _value, $Res Function(_$LatestReleaseImpl) _then)
      : super(_value, _then);


/// Create a copy of LatestRelease
/// with the given fields replaced by the non-null parameter values.
@pragma('vm:prefer-inline') @override $Res call({Object? id = null,Object? nodeId = null,Object? name = null,Object? tagName = null,Object? draft = null,Object? prerelease = null,Object? createdAt = null,Object? publishedAt = null,Object? assets = null,}) {
  return _then(_$LatestReleaseImpl(
id: null == id ? _value.id : id // ignore: cast_nullable_to_non_nullable
as int,nodeId: null == nodeId ? _value.nodeId : nodeId // ignore: cast_nullable_to_non_nullable
as String,name: null == name ? _value.name : name // ignore: cast_nullable_to_non_nullable
as String,tagName: null == tagName ? _value.tagName : tagName // ignore: cast_nullable_to_non_nullable
as String,draft: null == draft ? _value.draft : draft // ignore: cast_nullable_to_non_nullable
as bool,prerelease: null == prerelease ? _value.prerelease : prerelease // ignore: cast_nullable_to_non_nullable
as bool,createdAt: null == createdAt ? _value.createdAt : createdAt // ignore: cast_nullable_to_non_nullable
as DateTime,publishedAt: null == publishedAt ? _value.publishedAt : publishedAt // ignore: cast_nullable_to_non_nullable
as DateTime,assets: null == assets ? _value._assets : assets // ignore: cast_nullable_to_non_nullable
as List<LatestReleaseAsset>,
  ));
}


}

/// @nodoc


class _$LatestReleaseImpl extends _LatestRelease  {
  const _$LatestReleaseImpl({required this.id, required this.nodeId, required this.name, required this.tagName, required this.draft, required this.prerelease, required this.createdAt, required this.publishedAt, required final  List<LatestReleaseAsset> assets}): _assets = assets,super._();

  

@override final  int id;
@override final  String nodeId;
@override final  String name;
@override final  String tagName;
@override final  bool draft;
@override final  bool prerelease;
@override final  DateTime createdAt;
@override final  DateTime publishedAt;
 final  List<LatestReleaseAsset> _assets;
@override List<LatestReleaseAsset> get assets {
  if (_assets is EqualUnmodifiableListView) return _assets;
  // ignore: implicit_dynamic_type
  return EqualUnmodifiableListView(_assets);
}


@override
String toString() {
  return 'LatestRelease(id: $id, nodeId: $nodeId, name: $name, tagName: $tagName, draft: $draft, prerelease: $prerelease, createdAt: $createdAt, publishedAt: $publishedAt, assets: $assets)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$LatestReleaseImpl&&(identical(other.id, id) || other.id == id)&&(identical(other.nodeId, nodeId) || other.nodeId == nodeId)&&(identical(other.name, name) || other.name == name)&&(identical(other.tagName, tagName) || other.tagName == tagName)&&(identical(other.draft, draft) || other.draft == draft)&&(identical(other.prerelease, prerelease) || other.prerelease == prerelease)&&(identical(other.createdAt, createdAt) || other.createdAt == createdAt)&&(identical(other.publishedAt, publishedAt) || other.publishedAt == publishedAt)&&const DeepCollectionEquality().equals(other._assets, _assets));
}


@override
int get hashCode => Object.hash(runtimeType,id,nodeId,name,tagName,draft,prerelease,createdAt,publishedAt,const DeepCollectionEquality().hash(_assets));

/// Create a copy of LatestRelease
/// with the given fields replaced by the non-null parameter values.
@JsonKey(includeFromJson: false, includeToJson: false)
@override
@pragma('vm:prefer-inline')
_$$LatestReleaseImplCopyWith<_$LatestReleaseImpl> get copyWith => __$$LatestReleaseImplCopyWithImpl<_$LatestReleaseImpl>(this, _$identity);








}


abstract class _LatestRelease extends LatestRelease {
  const factory _LatestRelease({required final  int id, required final  String nodeId, required final  String name, required final  String tagName, required final  bool draft, required final  bool prerelease, required final  DateTime createdAt, required final  DateTime publishedAt, required final  List<LatestReleaseAsset> assets}) = _$LatestReleaseImpl;
  const _LatestRelease._(): super._();

  

@override int get id;@override String get nodeId;@override String get name;@override String get tagName;@override bool get draft;@override bool get prerelease;@override DateTime get createdAt;@override DateTime get publishedAt;@override List<LatestReleaseAsset> get assets;
/// Create a copy of LatestRelease
/// with the given fields replaced by the non-null parameter values.
@override @JsonKey(includeFromJson: false, includeToJson: false)
_$$LatestReleaseImplCopyWith<_$LatestReleaseImpl> get copyWith => throw _privateConstructorUsedError;

}
