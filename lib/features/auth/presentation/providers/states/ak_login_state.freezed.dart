// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'ak_login_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;


final _privateConstructorUsedError = UnsupportedError('It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AkLoginState {


@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  loggingIn,required TResult Function()  loggedIn,required TResult Function( AppFailure failure)  failed,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  loggingIn,TResult? Function()?  loggedIn,TResult? Function( AppFailure failure)?  failed,}) => throw _privateConstructorUsedError;
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  loggingIn,TResult Function()?  loggedIn,TResult Function( AppFailure failure)?  failed,required TResult orElse(),}) => throw _privateConstructorUsedError;





}

/// @nodoc
abstract class $AkLoginStateCopyWith<$Res>  {
  factory $AkLoginStateCopyWith(AkLoginState value, $Res Function(AkLoginState) then) = _$AkLoginStateCopyWithImpl<$Res, AkLoginState>;



}

/// @nodoc
class _$AkLoginStateCopyWithImpl<$Res,$Val extends AkLoginState> implements $AkLoginStateCopyWith<$Res> {
  _$AkLoginStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;



}


/// @nodoc
abstract class _$$InitImplCopyWith<$Res>  {
  factory _$$InitImplCopyWith(_$InitImpl value, $Res Function(_$InitImpl) then) = __$$InitImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$InitImplCopyWithImpl<$Res> extends _$AkLoginStateCopyWithImpl<$Res, _$InitImpl> implements _$$InitImplCopyWith<$Res> {
  __$$InitImplCopyWithImpl(_$InitImpl _value, $Res Function(_$InitImpl) _then)
      : super(_value, _then);





}

/// @nodoc


class _$InitImpl  implements _Init {
  const _$InitImpl();

  



@override
String toString() {
  return 'AkLoginState.init()';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$InitImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  loggingIn,required TResult Function()  loggedIn,required TResult Function( AppFailure failure)  failed,}) {
  return init();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  loggingIn,TResult? Function()?  loggedIn,TResult? Function( AppFailure failure)?  failed,}) {
  return init?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  loggingIn,TResult Function()?  loggedIn,TResult Function( AppFailure failure)?  failed,required TResult orElse(),}) {
  if (init != null) {
    return init();
  }
  return orElse();
}




}


abstract class _Init implements AkLoginState {
  const factory _Init() = _$InitImpl;
  

  



}

/// @nodoc
abstract class _$$LoggingInImplCopyWith<$Res>  {
  factory _$$LoggingInImplCopyWith(_$LoggingInImpl value, $Res Function(_$LoggingInImpl) then) = __$$LoggingInImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$LoggingInImplCopyWithImpl<$Res> extends _$AkLoginStateCopyWithImpl<$Res, _$LoggingInImpl> implements _$$LoggingInImplCopyWith<$Res> {
  __$$LoggingInImplCopyWithImpl(_$LoggingInImpl _value, $Res Function(_$LoggingInImpl) _then)
      : super(_value, _then);





}

/// @nodoc


class _$LoggingInImpl  implements _LoggingIn {
  const _$LoggingInImpl();

  



@override
String toString() {
  return 'AkLoginState.loggingIn()';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$LoggingInImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  loggingIn,required TResult Function()  loggedIn,required TResult Function( AppFailure failure)  failed,}) {
  return loggingIn();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  loggingIn,TResult? Function()?  loggedIn,TResult? Function( AppFailure failure)?  failed,}) {
  return loggingIn?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  loggingIn,TResult Function()?  loggedIn,TResult Function( AppFailure failure)?  failed,required TResult orElse(),}) {
  if (loggingIn != null) {
    return loggingIn();
  }
  return orElse();
}




}


abstract class _LoggingIn implements AkLoginState {
  const factory _LoggingIn() = _$LoggingInImpl;
  

  



}

/// @nodoc
abstract class _$$LoggedInImplCopyWith<$Res>  {
  factory _$$LoggedInImplCopyWith(_$LoggedInImpl value, $Res Function(_$LoggedInImpl) then) = __$$LoggedInImplCopyWithImpl<$Res>;



}

/// @nodoc
class __$$LoggedInImplCopyWithImpl<$Res> extends _$AkLoginStateCopyWithImpl<$Res, _$LoggedInImpl> implements _$$LoggedInImplCopyWith<$Res> {
  __$$LoggedInImplCopyWithImpl(_$LoggedInImpl _value, $Res Function(_$LoggedInImpl) _then)
      : super(_value, _then);





}

/// @nodoc


class _$LoggedInImpl  implements _LoggedIn {
  const _$LoggedInImpl();

  



@override
String toString() {
  return 'AkLoginState.loggedIn()';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$LoggedInImpl);
}


@override
int get hashCode => runtimeType.hashCode;


@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  loggingIn,required TResult Function()  loggedIn,required TResult Function( AppFailure failure)  failed,}) {
  return loggedIn();
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  loggingIn,TResult? Function()?  loggedIn,TResult? Function( AppFailure failure)?  failed,}) {
  return loggedIn?.call();
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  loggingIn,TResult Function()?  loggedIn,TResult Function( AppFailure failure)?  failed,required TResult orElse(),}) {
  if (loggedIn != null) {
    return loggedIn();
  }
  return orElse();
}




}


abstract class _LoggedIn implements AkLoginState {
  const factory _LoggedIn() = _$LoggedInImpl;
  

  



}

/// @nodoc
abstract class _$$FailedImplCopyWith<$Res>  {
  factory _$$FailedImplCopyWith(_$FailedImpl value, $Res Function(_$FailedImpl) then) = __$$FailedImplCopyWithImpl<$Res>;
@useResult
$Res call({
 AppFailure failure
});


$AppFailureCopyWith<$Res> get failure;
}

/// @nodoc
class __$$FailedImplCopyWithImpl<$Res> extends _$AkLoginStateCopyWithImpl<$Res, _$FailedImpl> implements _$$FailedImplCopyWith<$Res> {
  __$$FailedImplCopyWithImpl(_$FailedImpl _value, $Res Function(_$FailedImpl) _then)
      : super(_value, _then);


@pragma('vm:prefer-inline') @override $Res call({Object? failure = null,}) {
  return _then(_$FailedImpl(
null == failure ? _value.failure : failure // ignore: cast_nullable_to_non_nullable
as AppFailure,
  ));
}

@override
@pragma('vm:prefer-inline')
$AppFailureCopyWith<$Res> get failure {
  
  return $AppFailureCopyWith<$Res>(_value.failure, (value) {
    return _then(_value.copyWith(failure: value) );
  });
}
}

/// @nodoc


class _$FailedImpl  implements _Failed {
  const _$FailedImpl(this.failure);

  

@override final  AppFailure failure;

@override
String toString() {
  return 'AkLoginState.failed(failure: $failure)';
}


@override
bool operator ==(Object other) {
  return identical(this, other) || (other.runtimeType == runtimeType&&other is _$FailedImpl&&(identical(other.failure, failure) || other.failure == failure));
}


@override
int get hashCode => Object.hash(runtimeType,failure);

@JsonKey(ignore: true)
@override
@pragma('vm:prefer-inline')
_$$FailedImplCopyWith<_$FailedImpl> get copyWith => __$$FailedImplCopyWithImpl<_$FailedImpl>(this, _$identity);

@override
@optionalTypeArgs TResult when<TResult extends Object?>({required TResult Function()  init,required TResult Function()  loggingIn,required TResult Function()  loggedIn,required TResult Function( AppFailure failure)  failed,}) {
  return failed(failure);
}
@override
@optionalTypeArgs TResult? whenOrNull<TResult extends Object?>({TResult? Function()?  init,TResult? Function()?  loggingIn,TResult? Function()?  loggedIn,TResult? Function( AppFailure failure)?  failed,}) {
  return failed?.call(failure);
}
@override
@optionalTypeArgs TResult maybeWhen<TResult extends Object?>({TResult Function()?  init,TResult Function()?  loggingIn,TResult Function()?  loggedIn,TResult Function( AppFailure failure)?  failed,required TResult orElse(),}) {
  if (failed != null) {
    return failed(failure);
  }
  return orElse();
}




}


abstract class _Failed implements AkLoginState {
  const factory _Failed(final  AppFailure failure) = _$FailedImpl;
  

  

 AppFailure get failure;
@JsonKey(ignore: true)
_$$FailedImplCopyWith<_$FailedImpl> get copyWith => throw _privateConstructorUsedError;

}
